<!DOCTYPE html>
<html>
	<head>
		<title>Reported @ Nixu</title>
		<link rel="stylesheet" type="text/css" href="./index.css">
		<script type="text/javascript">
			// 595x842 (A4 apparently)
			let customer = 'Hvornum AB';
			let dates = '2019-11-21 - 2019-11-22';
			let final = true;

			let numbering = {
				'1' : true,
				'2' : true,
				'3' : false
			}

			let bullet_counters = {
				"1" : 0,
				"2" : 0,
				"3" : 0
			}

			function build_first_page() {
				let page = document.createElement('div');
				let paragraph = document.createElement('div');
				let doc = document.createElement('h1');
				let company = document.createElement('b');
				let date = document.createElement('span');

				doc.innerHTML = 'Nixu Pentest Report';
				company.innerHTML = customer;
				date.innerHTML = dates;

				page.classList = 'first-page';
				paragraph.classList = 'paragraph';
				paragraph.appendChild(doc);
				paragraph.appendChild(company);
				paragraph.appendChild(date);
				page.appendChild(paragraph);
				return page
			}

			function PrintRender(elem) {
				let reader = document.querySelector('#reader').innerHTML;
				var originalContents = document.body.innerHTML;

				let content = `
				<html xmlns="http://www.w3.org/1999/xhtml" lang='en-US'>
					<head>
						<link rel="stylesheet" type="text/css" href="./index.css">
					</head>
					<body>
						<div class="render" id="reader">
							${reader}
						</div>
					</body>
				</html>
				`
				document.body.innerHTML = content;
				window.print();
				
				document.body.innerHTML = originalContents;
			}

			function format_content(str) {
				return str;
			}

			function get_inherited_levels(level) {
				let lvl_str = '';
				for(let i=level; i>0; i--) {
					lvl_str = `${bullet_counters[i]}.` + lvl_str;
				}
				return lvl_str
			}

			function parse(markdown_raw) {
				// Clear the reader (right hand side)
				document.querySelector('#reader').innerHTML = '';
				markdown = markdown_raw.split('\n'); // Converts markdown to line-by-line

				// Keeps track of which numbering we're on (per level)
				// Activate / Disable numbering is done above (global variables)
				bullet_counters = {
					"1" : 0,
					"2" : 0,
					"3" : 0
				}

				// Add the first page to it.
				document.querySelector('#reader').appendChild(build_first_page());

				// Ok, so lets begin parsing.
				// We parse line-by-line!
				let section = null;
				let paragraph = null;
				let paragraph_text = null;
				for(var i = 0;i < markdown.length;i++){
					// If we find a paragraph, start a new paragraph
					if(markdown[i].substr(0, 1) == '#') {
						// And if a paragraph was already loaded, add that
						// to the reader
						if(paragraph_text) {
							let span = document.createElement('span');
							span.innerHTML = format_content(paragraph_text);
							paragraph.appendChild(span);
							document.querySelector('#reader').appendChild(paragraph);
							paragraph = null;
							paragraph_text = null;
						}

						// Grab the level-number by counting the number of #
						// Once we know how many we've got, remove them with substr()
						// so we're left with the section (title)
						let level = (markdown[i].match(/#/g) || []).length;
						section = markdown[i].substr(level).trim();
						// Create a paragraph placeholder to contain the header and body of
						// the paragraph itself.
						if(!paragraph) {
							paragraph = document.createElement('div');
							paragraph.classList = 'paragraph indent-'+level
						}

						// Add the header to the paragraph,
						// Body will be added later once we know how much text should
						// be added (remember, we're line by line still..)
						let h = document.createElement(`h${level}`)
						if(numbering[level] !== false) {
							bullet_counters[level] += 1
							let level_num_str = get_inherited_levels(level)
							h.innerHTML = `${level_num_str} ${section}`;
						} else {
							h.innerHTML = section;
						}
						paragraph.appendChild(h);
					} else {
						if(!paragraph_text) {
							paragraph_text = markdown[i] + '<br>';
						} else {
							paragraph_text += markdown[i] + '<br>';
						}
					}
				}

				// Finally, if we're left with a paragraph_text at the 
				// end of parsing, add it to the reader..
				// We do this since there won't be any more # starting new paragraphs
				// which is usually when we add the paragraph text.
				if(paragraph_text) {
					let span = document.createElement('span');
					span.innerHTML = format_content(paragraph_text);
					paragraph.appendChild(span);
					document.querySelector('#reader').appendChild(paragraph);
					paragraph = null;
					paragraph_text = null;
				}
			}

			window.onload = function() {
				// Initial parsing, adding event listeners to parse() on change/input.
				let md = document.querySelector('#markdown');
				parse(md.value)

				md.addEventListener('input', function() {
					parse(this.value);
				})
				md.addEventListener('change', function() {
					parse(this.value);
				})
			}

			document.addEventListener("keydown", function(e) {
				// Prevent Ctr-S (or CMD+S on Mac) to open the "Save as" window,
				// Since this is not a document, people might spam Ctrl-S to save.. which is annoying.
				if ((window.navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)  && e.keyCode == 83) {
					e.preventDefault();
				}
			}, false);
		</script>
	</head>
	<body>
		<div class="editor">
			<textarea class="input" id="markdown"># Executive Summary
Hvornum AB was lacking in certain departments.
And he didn't make up for it in afternoon fika.

# Table Of Contents
:toc{1,2}

# Findings overview
:prio{2}

# Finding Details

## Penetration not possible

### Description
Hvornum AB has a very strong anti-penetration aura. This is a clear vulnerability.

### Proposed Solution
Better fashion sense

## Weak passwords

### Description
Clear weak passwords.

![img](https://miro.medium.com/max/610/1*xwScPTcIGgjWfZIcEeR2oA.png)
</textarea>
		</div>
		<div class="render" id="reader" onClick="PrintRender();">
		</div>
	</body>
</html>